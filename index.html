<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <title>Site Eval Dashboard (PoC)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px;}
    .wrap{display:grid;grid-template-columns:1fr 1fr;gap:24px;}
    .card{padding:16px;border:1px solid #ddd;border-radius:12px;}
    h2{margin:.2em 0}
    .code{font-family:ui-monospace,Menlo,Consolas,monospace}
    .muted{color:#666;font-size:.9em}
    .toast{position:fixed;top:20px;right:20px;padding:12px 20px;background:#4caf50;color:white;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,0.1);z-index:1000;animation:slideIn 0.3s;}
    .toast.error{background:#f44336}
    .toast.info{background:#2196f3}
    @keyframes slideIn{from{transform:translateX(100%);opacity:0}to{transform:translateX(0);opacity:1}}
    .polling{display:inline-block;margin-left:8px;color:#666;font-size:.9em}
    .polling::after{content:'●';animation:pulse 1s infinite}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.3}}
    #historySelect{margin:8px 0;padding:4px 8px;font-size:.9em}
    .top-drivers{list-style:none;padding:0;margin:8px 0}
    .top-drivers li{padding:4px 0;border-bottom:1px solid #eee}
    .top-drivers li:last-child{border-bottom:none}
    .tier3-section{margin-top:24px}
    .tier3-theme-group{margin-bottom:32px}
    .tier3-theme-header{font-size:1.1em;font-weight:600;margin-bottom:12px;padding-bottom:8px;border-bottom:2px solid #ddd}
    .tier3-table{width:100%;border-collapse:collapse;margin-top:8px}
    .tier3-table th{text-align:left;padding:8px 12px;background:#f5f5f5;border-bottom:2px solid #ddd;font-size:.9em;font-weight:600}
    .tier3-table td{padding:10px 12px;border-bottom:1px solid #eee;font-size:.9em;vertical-align:top}
    .tier3-table tr:hover{background:#fafafa}
    .tier3-badge{display:inline-block;padding:2px 8px;border-radius:4px;font-size:.8em;font-weight:500;margin-right:4px}
    .tier3-badge.warmth{background:#ffebee;color:#c62828}
    .tier3-badge.competence{background:#e3f2fd;color:#1565c0}
    .tier3-badge.momentum{background:#f1f8e9;color:#558b2f}
    .tier3-score{font-weight:600;color:#333}
    .tier3-reason{color:#555;line-height:1.5}
    .tier3-evidence{color:#666;font-size:.85em;line-height:1.4}
    .tier3-evidence ul{margin:4px 0;padding-left:20px}
    .tier3-evidence li{margin:2px 0}
    .tier3-empty{color:#999;font-style:italic}
  </style>
</head>
<body>
  <div id="header" class="card"></div>
<script>
function renderHeader(data){
  const st = data.site_type || {};
  const conf = st.confidence || {}; // {W_C:0.78 ...} を出せるなら（なければ省略）
  const pct = v => (typeof v === 'number' ? Math.round(v*100) + '%' : '-');
  const confLine = (k) => conf[k] != null ? ` (${pct(conf[k])})` : '';
  document.getElementById('header').innerHTML = `
    <h2>Site Type Code: <span class="code">${st.code || '-'}</span></h2>
    <div>W/C=${st?.W_C?.pole||'-'}${confLine('W_C')} /
         B/S=${st?.B_S?.pole||'-'}${confLine('B_S')} /
         F/L=${st?.F_L?.pole||'-'}${confLine('F_L')} /
         H/T=${st?.H_T?.pole||'-'}${confLine('H_T')}</div>
  `;
}
</script>
  <h1>Site Eval Dashboard (PoC)</h1>
  <form id="runForm" class="card" style="margin:16px 0;">
  <label>評価URL: <input name="url" type="url" required style="width:60%"></label>
  <select name="engine">
    <option value="claude">claude</option>
    <option value="codex">codex</option>
  </select>
  <button type="submit">評価ジョブを作成</button>
  <span id="runMsg"></span>
</form>
<div class="card" style="margin:16px 0;">
  <label>履歴: <select id="historySelect"><option value="">最新を表示</option></select></label>
</div>
<script>
/** =============================
 *  CONFIG（設定の一元化）
 *  ============================= */
const BASE_API = 'https://script.google.com/macros/s/AKfycbw9Mcy1bMlhGehGSV_N_QzdGTBTWnfZkd-Tb2o79rbIZ9dHiIa6RH9t0RCn2Ry8MjemsQ/exec'; // スコア閲覧API（変更なし）
const JOB_API = 'https://script.google.com/macros/s/AKfycbx48PqKNVaQcNvThNJLKQNc9I2Qexlbuy3b-FPrNeOJaT6fcvuGldj6FPgrCl8sD0qh/exec'; // ジョブAPI（新規プロジェクト）
const DEFAULT_QUERY = 'latest=1';
const TOKEN = ''; // 今はREQUIRE_TOKEN=falseなので空でOK

// デバッグ用：実際に使われているURLを確認
console.log('BASE_API:', BASE_API);
console.log('JOB_API:', JOB_API);

// クエリパラメータを安全に追加するユーティリティ
function withParams(base, obj){
  const u = new URL(base);
  Object.entries(obj).forEach(([k,v])=>{
    if (v !== undefined && v !== null && v !== '') u.searchParams.set(k, v);
  });
  return u.toString();
}

// トースト表示
function showToast(message, type='success'){
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  toast.textContent = message;
  document.body.appendChild(toast);
  setTimeout(()=>{
    toast.style.animation = 'slideIn 0.3s reverse';
    setTimeout(()=>toast.remove(), 300);
  }, 3000);
}

// 1) ジョブ投入時：サーバ生成 run_id / job_id を受け取る
async function enqueueJob(urlValue, engine){
  const params = new URLSearchParams();
  params.set('action', 'enqueue');
  params.set('url', urlValue);
  params.set('engine', engine || 'claude');
  params.set('themes', 'ALL');
  params.set('allowed_items', 'ALL');
  // TOKENが空でない場合のみ追加（REQUIRE_TOKEN=falseの場合は空でOK）
  if (TOKEN && TOKEN.trim() !== '') {
    params.set('token', TOKEN);
  }

  const r = await fetch(JOB_API, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: params.toString()
  });
  
  if (!r.ok) {
    throw new Error(`HTTP ${r.status}: ${r.statusText}`);
  }
  
  const j = await r.json();
  if (!j.ok) {
    throw new Error(j.error || 'enqueue failed');
  }
  
  return { job_id: j.job_id, run_id: j.run_id };
}

// 2) /status を5秒間隔で監視（0/25/50/75/100）→ 100で即座に run_id で再読込
// TODO: runIdFromServerは将来の拡張用に予約（現時点では未使用）
async function startPolling(jobId, runIdFromServer){
  const MAX_TRIES = 18; // 90秒（5秒×18）
  const pollMsg = document.getElementById('runMsg');
  
  for (let i = 0; i < MAX_TRIES; i++){
    try {
      const url = withParams(BASE_API, { 
        status: 1, 
        job_id: jobId,
        token: (TOKEN && TOKEN.trim() !== '') ? TOKEN : undefined
      });
      
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      }
      
      const j = await res.json().catch(() => ({}));
      
      const prog = Number(j.progress?.ratio ?? 0);
      const status = j.status || 'unknown';
      
      // 進捗バー更新（任意）
      const progPct = Math.round(prog);
      pollMsg.innerHTML = `解析中... ${progPct}% <span class="polling"></span>`;
      console.log('status:', prog, status, j.last_error || '');
      
      if (status === 'done' && j.run_id){
        pollMsg.textContent = '評価完了！';
        showToast('評価が完了しました', 'success');
        // ページを再読み込み（run_id付き）
        const dest = withParams(location.origin + location.pathname, { run_id: j.run_id });
        location.replace(dest);
        return;
      }
      
      if (status === 'failed'){
        throw new Error(j.last_error || 'runner failed');
      }
      
      // 5秒待機
      await new Promise(r => setTimeout(r, 5000));
    } catch(e) {
      console.error('Polling error:', e);
      if (i === MAX_TRIES - 1) {
        throw e; // 最後の試行でエラーなら再スロー
      }
      await new Promise(r => setTimeout(r, 5000)); // エラー時も5秒待機
    }
  }
  
  // タイムアウト
  pollMsg.innerHTML = '結果が遅延しています。<a href="?latest=1" style="color:#2196f3;text-decoration:underline">履歴から再表示してください</a>';
  showToast('ポーリングがタイムアウトしました。履歴から確認してください。', 'info');
  throw new Error('timeout waiting for status=done');
}

// フォーム送信
// 3) submit ハンドラ
document.getElementById('runForm').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const btn = e.target.querySelector('button[type="submit"]');
  btn.disabled = true;
  btn.textContent = '登録中...';
  
  try{
    const fd = new FormData(e.target);
    const urlValue = fd.get('url') || '';

    // 軽バリデーション
    try {
      const u = new URL(urlValue);
      if (!/^https?:$/.test(u.protocol)) {
        throw new Error('URL protocol must be http/https');
      }
    } catch (urlErr) {
      showToast(`URLが不正です: ${String(urlErr)}`, 'error');
      btn.disabled = false;
      btn.textContent = '評価ジョブを作成';
      return;
    }

    // enqueue → status polling → 自動遷移
    const { job_id, run_id } = await enqueueJob(urlValue, fd.get('engine'));
    
    // デバッグ用にクエリへ保持
    history.replaceState(null, '', withParams(location.href, { job_id, run_id }));
    
    showToast(`ジョブ登録完了: ${job_id}`, 'success');
    
    // ポーリング開始（/statusベース）
    await startPolling(job_id, run_id);
    
  } catch(err){
    console.error('Form submit error:', err);
    showToast(`ジョブ開始に失敗: ${String(err)}`, 'error');
    btn.disabled = false;
    btn.textContent = '評価ジョブを作成';
  }
});

// 履歴セレクタ
async function loadHistory(){
  const select = document.getElementById('historySelect');
  select.innerHTML = '<option value="">読み込み中…</option>';
  
  try{
    const API = buildApiUrl(BASE_API, '');
    const url = withParams(API, { list: 1, limit: 20 });
    const resp = await fetch(url);
    const payload = await resp.json();
    
    if (payload.ok && payload.data){
      select.innerHTML = '<option value="">最新を表示</option>';
      payload.data.forEach(item=>{
        const opt = document.createElement('option');
        opt.value = item.run_id;
        // ラベル順序：RunID → SiteType → 日時 → Engine（視線の流れを最適化）
        const dateStr = item.evaluated_at ? new Date(item.evaluated_at).toLocaleString('ja-JP') : '';
        const labelText = `${item.run_id} - ${item.site_type_code || '-'} - ${dateStr} - ${item.engine_label}`;
        opt.textContent = labelText;
        // title属性でロングテキストのホバー確認を可能に
        opt.title = labelText;
        select.appendChild(opt);
      });
      
      // 現在のrun_idと一致するものを選択
      const qs = new URLSearchParams(location.search);
      const currentRunId = qs.get('run_id');
      if (currentRunId){
        select.value = currentRunId;
      }
    } else {
      select.innerHTML = '<option value="">取得失敗</option>';
    }
  }catch(e){
    console.error('History load error:', e);
    select.innerHTML = '<option value="">取得失敗</option>';
  }
}

document.getElementById('historySelect').addEventListener('change', (e)=>{
  const runId = e.target.value;
  if (runId){
    // 特定のrun_idを選択：run_idを優先（latestは無視）
    window.location.href = `?run_id=${encodeURIComponent(runId)}`;
  } else {
    // 「最新を表示」を選択：latest=1をセット（run_idをクリア）
    window.location.href = '?latest=1';
  }
});

// ページ読み込み時に履歴を読み込む（buildApiUrl定義後に実行）
// loadHistory()は後で実行される（buildApiUrl定義後）
</script>
  <div id="meta" class="card">Loading…</div>
  <div class="wrap">
    <div class="card"><h2>Tier1（三角値）</h2><div id="t1"></div></div>
    <div class="card">
      <h2>Tier2（レーダー）</h2>
      <canvas id="radar" height="280"></canvas>
      <div style="margin-top:16px;">
        <h3 style="font-size:1em;margin:.5em 0">Top Drivers</h3>
        <ul id="topDrivers" class="top-drivers"></ul>
      </div>
    </div>
  </div>
  <div class="card tier3-section">
    <h2>詳細診断（Tier3指標）</h2>
    <div id="tier3Detail"></div>
  </div>

<script>
/** =============================
 *  Build API URL from querystring
 *  ============================= */
function buildApiUrl(base, defaultQuery) {
  const qsIn = new URLSearchParams(location.search);
  const qsOut = new URLSearchParams();

  // 透過パラメタ：run_id / engine / token / latest / list
  // 注意: run_id と latest が同時に指定された場合は run_id を優先（明示指定を尊重）
  ['run_id', 'engine', 'token', 'latest', 'list', 'limit'].forEach(k => {
    const v = qsIn.get(k);
    if (v != null && v !== '') qsOut.set(k, v);
  });

  // run_idがあればlatestを削除（run_id優先を実装で明示）
  if (qsOut.has('run_id')) {
    qsOut.delete('latest');
  }

  // 何も指定がなければ latest=1 を追加
  if (![...qsOut.keys()].length) {
    defaultQuery.split('&').forEach(pair => {
      const [k, v] = pair.split('=');
      if (k) qsOut.set(k, v ?? '');
    });
  }

  const s = qsOut.toString();
  return s ? `${base}?${s}` : base;
}

(async function () {
  /** =============================
   *  CONFIG
   *  ============================= */
  const API = buildApiUrl(BASE_API, DEFAULT_QUERY);

  /** =============================
   *  Fetch & Normalize
   *  ============================= */
  let payload;
  try {
    const resp = await fetch(API, { method: 'GET' });
    if (!resp.ok) {
      throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
    }
    payload = await resp.json();
  } catch (e) {
    // Network失敗時はリトライボタンを表示
    const isNetworkError = e instanceof TypeError || e.message.includes('fetch');
    showError(`API fetch failed: ${String(e)}`, isNetworkError);
    return;
  }
  if (!payload || payload.ok === false) {
    showError(`API error: ${payload && (payload.error || 'unknown')}`);
    return;
  }

  const raw = payload.data;
  // デバッグ用：実際のデータ構造を確認
  console.log('Raw data:', raw);
  console.log('Is array:', Array.isArray(raw));
  if (Array.isArray(raw)) {
    console.log('Tier2 rows:', raw.filter(r => r.tier === 'tier2'));
    console.log('Tier2 normalized_100 rows:', raw.filter(r => r.tier === 'tier2' && r.metric === 'normalized_100'));
  }
  
  // フラット(scores_flat) or ネスト(scores) をユニファイ
  const model = Array.isArray(raw) ? fromFlat(raw) : fromNested(raw);
  
  // デバッグ用：正規化後のデータを確認
  console.log('Normalized model:', model);
  console.log('Tier2 in model:', model.tier2);

  /** =============================
   *  Render Header (Site Type)
   *  ============================= */
  try {
    renderHeader({ site_type: model.site_type });
  } catch (e) {
    // headerは必須ではないので握りつぶし
  }

  /** =============================
   *  Render (Meta)
   *  ============================= */
  const metaEl = document.getElementById('meta');
  metaEl.innerHTML = `
    <h2>対象</h2>
    <div>URL: <a href="${escapeHtml(model.target_url||'-')}" target="_blank" rel="noreferrer">${escapeHtml(model.target_url||'-')}</a></div>
    <div>Run: <span class="code">${escapeHtml(model.run_id||'-')}</span> / Engine: ${escapeHtml(model.engine_label||'-')}</div>
    <div>SiteType: <span class="code">${escapeHtml(model.site_type?.code||'-')}</span>
      （W/C=${escapeHtml(model.site_type?.W_C?.pole||'-')} /
         B/S=${escapeHtml(model.site_type?.B_S?.pole||'-')} /
         F/L=${escapeHtml(model.site_type?.F_L?.pole||'-')} /
         H/T=${escapeHtml(model.site_type?.H_T?.pole||'-')}）</div>
    <div>Evaluated: ${escapeHtml(model.evaluated_at||'-')}</div>
    ${payload.source ? `<div class="muted">source: ${escapeHtml(payload.source.file_name||'')} / ${escapeHtml(payload.source.last_updated_iso||'')}</div>` : '' }
  `;

  /** =============================
   *  Render (Tier1)
   *  ============================= */
  const t1Div = document.getElementById('t1');
  if ((model.tier1||[]).length) {
    const line = model.tier1.map(x => `${escapeHtml(x.name)}: <b>${x.normalized_100 ?? '-'}</b>`).join(' / ');
    t1Div.innerHTML = line;
  } else {
    t1Div.textContent = '—';
  }

  /** =============================
   *  Render (Tier2 → Radar / Bar fallback)
   *  ============================= */
  const t2 = (model.tier2 || []).filter(x => typeof x.normalized_100 === 'number');
  const ctx = document.getElementById('radar').getContext('2d');

  // 既存のChartインスタンスを破棄（SPA化時のメモリリーク防止）
  const existingChart = Chart.getChart(ctx.canvas);
  if (existingChart) {
    existingChart.destroy();
  }

  if (t2.length >= 3) {
    new Chart(ctx, {
      type:'radar',
      data:{
        labels: t2.map(d=>d.name),
        datasets:[{ label:'Tier2', data: t2.map(d=>d.normalized_100), fill:true }]
      },
      options:{
        responsive:true,
        scales:{ r:{ suggestedMin:0, suggestedMax:100, ticks:{ stepSize:20 } } },
        plugins:{ legend:{ display:false } }
      }
    });
  } else if (t2.length > 0) {
    // 2軸以下はバー表示（1軸もバーで表示）
    new Chart(ctx, {
      type:'bar',
      data:{
        labels: t2.map(d=>d.name),
        datasets:[{ label:'Tier2', data: t2.map(d=>d.normalized_100) }]
      },
      options:{
        indexAxis:'y',
        responsive:true,
        scales:{ x:{ min:0, max:100, ticks:{ stepSize:20 } } },
        plugins:{ legend:{ display:false } }
      }
    });
  } else {
    // canvasの親要素が存在する場合のみ更新
    const canvasParent = ctx.canvas.parentElement;
    if (canvasParent) {
      canvasParent.innerHTML = '<div>Tier2データがありません</div>';
    } else {
      console.warn('Tier2 canvas parent element not found');
    }
  }

  /** =============================
   *  Render (Top Drivers)
   *  ============================= */
  const topDriversEl = document.getElementById('topDrivers');
  // 数値フォーマッタ：整数なら整数表示、小数なら小数1桁（将来の要望に備えて関数化）
  const fmt = v => Number.isFinite(v) ? (v % 1 === 0 ? String(v) : v.toFixed(1)) : '-';
  
  if (topDriversEl) {
    if (t2.length > 0){
      const sorted = [...t2].sort((a,b) => (b.normalized_100 || 0) - (a.normalized_100 || 0));
      const top3 = sorted.slice(0, 3);
      topDriversEl.innerHTML = top3.map(d => {
        const val = fmt(d.normalized_100);
        return `<li><strong>${escapeHtml(d.name)}</strong>: ${val}</li>`;
      }).join('');
    } else {
      topDriversEl.innerHTML = '<li>データがありません</li>';
    }
  } else {
    console.warn('topDrivers element not found');
  }

  /** =============================
   *  Tier3詳細診断の描画
   *  ============================= */
  try {
    await renderTier3Detail(model);
  } catch (e) {
    console.warn('Tier3 detail render error:', e);
    const tier3El = document.getElementById('tier3Detail');
    if (tier3El) {
      tier3El.innerHTML = '<div class="tier3-empty">Tier3データの読み込みに失敗しました</div>';
    }
  }

  /** =============================
   *  Helpers
   *  ============================= */
  async function renderTier3Detail(model) {
    const tier3El = document.getElementById('tier3Detail');
    if (!tier3El) return;

    // Tier3データを取得
    let tier3Data = [];
    try {
      // まず tier3_explained.json を試す
      const runId = model.run_id;
      if (runId) {
        const tier3ApiUrl = withParams(BASE_API, { tier3_explained: 1, run_id: runId });
        const tier3Resp = await fetch(tier3ApiUrl);
        if (tier3Resp.ok) {
          const tier3Payload = await tier3Resp.json();
          if (tier3Payload.ok && tier3Payload.data && Array.isArray(tier3Payload.data.tier3)) {
            tier3Data = tier3Payload.data.tier3;
          }
        }
      }
    } catch (e) {
      console.warn('tier3_explained.json fetch failed, trying fallback:', e);
    }

    // フォールバック: 既存のAPIからTier3データを取得
    if (tier3Data.length === 0) {
      try {
        const raw = payload.data;
        if (Array.isArray(raw)) {
          tier3Data = raw
            .filter(r => r.tier === 'tier3')
            .map(r => ({
              id: r.id || '',
              name_ja: r.name || '',
              theme: r.theme || '',
              score: r.value || null,
              tier1_weights: extractTier1Weights(r, model),
              reason: r.reason || '',
              evidence: Array.isArray(r.evidence) ? r.evidence : []
            }));
        }
      } catch (e) {
        console.warn('Fallback tier3 fetch failed:', e);
      }
    }

    // Tier2（theme）ごとにグルーピング
    const grouped = groupTier3ByTheme(tier3Data);

    // 描画
    if (Object.keys(grouped).length === 0) {
      tier3El.innerHTML = '<div class="tier3-empty">Tier3データがありません</div>';
      return;
    }

    let html = '';
    for (const [theme, items] of Object.entries(grouped)) {
      html += `<div class="tier3-theme-group">`;
      html += `<div class="tier3-theme-header">${escapeHtml(theme)}</div>`;
      html += `<table class="tier3-table">`;
      html += `<thead><tr><th>指標名</th><th>スコア</th><th>寄与軸</th><th>理由</th><th>根拠</th></tr></thead>`;
      html += `<tbody>`;
      
      for (const item of items) {
        // スコア: Tier3は1-5スケール（将来0-100に変更する可能性あり）
        const score = item.score !== null && item.score !== undefined ? item.score : '-';
        
        // reason: セキュリティのため必ずescape（未設定時のみHTML）
        const reasonHtml = item.reason
          ? escapeHtml(item.reason)
          : '<span class="tier3-empty">未設定</span>';
        
        // evidence: string配列またはオブジェクト配列の両方に対応（将来拡張対応）
        const evidenceList = Array.isArray(item.evidence) ? item.evidence : [];
        const evidence = evidenceList.length > 0
          ? `<ul>${evidenceList.map(ev => {
              const text = typeof ev === 'string' ? ev : (ev.text || '');
              return `<li>${escapeHtml(text)}</li>`;
            }).join('')}</ul>`
          : '<span class="tier3-empty">未設定</span>';
        
        // 寄与軸バッジを生成
        const badges = renderTier1Badges(item.tier1_weights);
        
        html += `<tr>`;
        html += `<td>${escapeHtml(item.name_ja)}</td>`;
        html += `<td><span class="tier3-score">${score}</span></td>`;
        html += `<td>${badges}</td>`;
        html += `<td class="tier3-reason">${reasonHtml}</td>`;
        html += `<td class="tier3-evidence">${evidence}</td>`;
        html += `</tr>`;
      }
      
      html += `</tbody></table>`;
      html += `</div>`;
    }

    tier3El.innerHTML = html;
  }

  function groupTier3ByTheme(tier3Data) {
    const grouped = {};
    for (const item of tier3Data) {
      const theme = item.theme || '未分類';
      if (!grouped[theme]) {
        grouped[theme] = [];
      }
      grouped[theme].push(item);
    }
    // 各テーマ内でスコアの降順でソート
    for (const theme in grouped) {
      grouped[theme].sort((a, b) => {
        const scoreA = a.score !== null && a.score !== undefined ? a.score : -1;
        const scoreB = b.score !== null && b.score !== undefined ? b.score : -1;
        return scoreB - scoreA;
      });
    }
    return grouped;
  }

  function extractTier1Weights(tier3Row, model) {
    // tier3Rowからtier1_weightsを抽出、なければthemeから推測
    if (tier3Row.tier1_weights && typeof tier3Row.tier1_weights === 'object') {
      return tier3Row.tier1_weights;
    }
    
    // themeからTier2を特定し、Tier2のtier1_mappingから推測
    // TODO: 将来的には tier2_id や theme_id などの機械可読なIDで紐付けに変更予定
    // 現時点では theme（Tier2のname）との完全一致でマッチング
    const theme = tier3Row.theme || '';
    if (!theme) return { Warmth: 0, Competence: 0, Momentum: 0 };
    
    // model.tier2から該当するTier2を探す
    const tier2 = (model.tier2 || []).find(t2 => t2.name === theme);
    if (tier2 && tier2.tier1_weights) {
      return tier2.tier1_weights;
    }
    
    // デフォルト: すべて0
    return { Warmth: 0, Competence: 0, Momentum: 0 };
  }

  function renderTier1Badges(tier1Weights) {
    if (!tier1Weights || typeof tier1Weights !== 'object') {
      return '<span class="tier3-empty">-</span>';
    }
    
    // バックエンドの実データ仕様に合わせて、大文字始まりと小文字の両方に対応
    // TODO: スキーマ確定後は片方に統一してこのフォールバックを削除
    const w = tier1Weights.Warmth ?? tier1Weights.warmth ?? 0;
    const c = tier1Weights.Competence ?? tier1Weights.competence ?? 0;
    const m = tier1Weights.Momentum ?? tier1Weights.momentum ?? 0;
    
    const badges = [];
    if (w > 0) {
      badges.push(`<span class="tier3-badge warmth">W</span>`);
    }
    if (c > 0) {
      badges.push(`<span class="tier3-badge competence">C</span>`);
    }
    if (m > 0) {
      badges.push(`<span class="tier3-badge momentum">M</span>`);
    }
    
    return badges.length > 0 ? badges.join('') : '<span class="tier3-empty">-</span>';
  }

  function fromFlat(rows) {
    // 代表メタ
    const meta = rows[0] || {};
    const run_id = meta.run_id || null;
    const engine_label = meta.engine_label || null;
    const target_url = meta.target_url || null;

    // Tier1
    const t1 = rows
      .filter(r => r.tier === 'tier1' && r.metric === 'normalized_100')
      .map(r => ({ name: r.name, normalized_100: r.value }));

    // Tier2
    const t2 = rows
      .filter(r => r.tier === 'tier2' && r.metric === 'normalized_100')
      .map(r => ({ name: r.name, normalized_100: r.value }));

    // SiteType
    const code = pickFlat(rows, 'site_type', 'code', 'code');
    const wc   = pickFlat(rows, 'site_type', 'W_C', 'pole');
    const bs   = pickFlat(rows, 'site_type', 'B_S', 'pole');
    const fl   = pickFlat(rows, 'site_type', 'F_L', 'pole');
    const ht   = pickFlat(rows, 'site_type', 'H_T', 'pole');

    return {
      run_id, engine_label, target_url,
      evaluated_at: null, // flatには無い想定
      tier1: t1, tier2: t2,
      site_type: {
        code,
        W_C: wc ? { pole: wc } : null,
        B_S: bs ? { pole: bs } : null,
        F_L: fl ? { pole: fl } : null,
        H_T: ht ? { pole: ht } : null
      }
    };
  }

  function pickFlat(rows, tier, name, metric) {
    const hit = rows.find(r => r.tier === tier && r.name === name && r.metric === metric);
    return hit ? hit.value : null;
  }

  function fromNested(obj) {
    // tier1_scores が {Warmth:30,...} なら配列化
    let t1 = [];
    if (Array.isArray(obj.tier1)) {
      t1 = obj.tier1.map(x => ({ name: x.name, normalized_100: x.normalized_100 ?? x.normalized }));
    } else if (obj.tier1_scores && typeof obj.tier1_scores === 'object') {
      t1 = Object.entries(obj.tier1_scores).map(([k, v]) => ({ name: k, normalized_100: v }));
    }

    // tier2_scores 配列 → normalized_100を拾う
    const t2src = obj.tier2 || obj.tier2_scores || [];
    const t2 = (Array.isArray(t2src) ? t2src : []).map(x => ({
      name: x.name, normalized_100: x.normalized_100 ?? x.normalized
    }));

    return {
      run_id: obj.metadata?.run_id || obj.run?.run_id || null,
      engine_label: obj.metadata?.engine_label || obj.run?.engine_label || null,
      target_url: obj.metadata?.target_url || obj.run?.target_url || null,
      evaluated_at: obj.metadata?.evaluated_at || null,
      tier1: t1,
      tier2: t2,
      site_type: obj.site_type || null
    };
  }

  function escapeHtml(s) {
    return String(s ?? '').replace(/[&<>"']/g, c => (
      {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'}[c]
    ));
  }

  function showError(msg, isNetworkError = false){
    // 例外時のUI連動：全セクションを「データなし」表示に切替
    const meta = document.getElementById('meta');
    let errorHtml = `<div style="color:#b00">Error: ${escapeHtml(msg)}</div>
      <div class="muted">API: ${escapeHtml(API)}</div>`;
    
    // Network失敗時のみリトライボタンを表示
    if (isNetworkError) {
      errorHtml += `<div style="margin-top:12px;">
        <button onclick="window.location.reload()" style="padding:8px 16px;background:#2196f3;color:white;border:none;border-radius:4px;cursor:pointer;">
          リトライ
        </button>
      </div>`;
    }
    
    meta.innerHTML = errorHtml;
    
    // Headerをクリア
    const header = document.getElementById('header');
    if (header) {
      header.innerHTML = '<h2>Site Type Code: <span class="code">-</span></h2><div>データなし</div>';
    }
    
    // Tier1をクリア
    const t1Div = document.getElementById('t1');
    if (t1Div) {
      t1Div.textContent = '—';
    }
    
    // Tier2チャートをクリア（canvasは残して中身だけクリア）
    const radarEl = document.getElementById('radar');
    if (radarEl) {
      // canvasをcloneNodeで置き換え（再描画ロジックが同一DOM前提でも安全）
      const newCanvas = radarEl.cloneNode(true);
      radarEl.replaceWith(newCanvas);
      // 親要素にメッセージを追加
      const parent = newCanvas.parentElement;
      if (parent && !parent.querySelector('.error-msg')) {
        const msg = document.createElement('div');
        msg.className = 'error-msg';
        msg.textContent = 'Tier2データがありません';
        msg.style.marginTop = '8px';
        msg.style.color = '#666';
        parent.appendChild(msg);
      }
    }
    
    // Top Driversをクリア
    const topDriversEl = document.getElementById('topDrivers');
    if (topDriversEl) {
      topDriversEl.innerHTML = '<li>データがありません</li>';
    }
  }
})();

// ページ読み込み時に履歴を読み込む（buildApiUrl定義後に実行）
loadHistory();
</script>
</body>
</html>
